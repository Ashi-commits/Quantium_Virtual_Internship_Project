# Solution for Task 1
# Load required libraries and datasets
# Note that you will need to install these libraries if you have never used these before.
# Load required libraries
install.packages("data.table")
library(data.table)
library(ggplot2)
library(ggmosaic)
library(readr)
install.packages("readxl")
library(readxl)

# Point the filePath to where you have downloaded the datasets to and
# assign the data files to data.tables
# over to you! fill in the path to your working directory. If you are on a Windows
# machine, you will need to use forward slashes (/) instead of backslashes (\)

filePath <- "C:/Users/Ayushi/Downloads/"
transactionData <- read_excel(paste0(filePath, "QVI_transaction_data.xlsx"))

customerData <- read_csv("C:/Users/Ayushi/Downloads/QVI_purchase_behaviour.csv")

# Exploratory data analysis
# The first step in any analysis is to first understand the data. Let's take a look
# at each of the datasets provided.

# Examining transaction data
# We can use str() to look at the format of each column and see a sample of the
# data. As we have read in the dataset as a data.table object, we can also run
# transactionData in the console to see a sample of the data or use
# head(transactionData) to look at the first 10 rows.

# Check if columns we would expect to be numeric are in numeric form and date
# columns are in date format.
str(transactionData)

# Convert DATE to date format
# A quick search online tells us that CSV and Excel integer dates begin on 30 Dec 1899
transactionData$DATE <- as.Date(transactionData$DATE, origin = "1899-12-30")

# Check that we are looking at the right products by examining PROD_NAME.
str(transactionData)
colnames(transactionData)
colnames(transactionData) <- trimws(colnames(transactionData))
head(transactionData)

summary(transactionData$PROD_NAME)

# Examine the words in PROD_NAME to see if there are any incorrect entries
# such as products that are not chips
productWords <- data.table(unlist(strsplit(unique(transactionData$PROD_NAME), " ")))
setnames(productWords, 'words')

# Assuming transactionData is a tibble (data frame)
# Convert it to a data.table
transactionData <- as.data.table(transactionData)

# Convert product names to lowercase for consistency
transactionData[, PROD_NAME := tolower(PROD_NAME)]

# Split and unlist the words from the product names
productWords <- data.table(unlist(strsplit(unique(transactionData[, PROD_NAME]), " ")))

# Remove digits and special characters
productWords <- productWords[!grepl("\\d", V1)]
productWords <- productWords[!grepl("[[:punct:]]", V1)]

# Count the number of times each word appears and sort them by frequency in descending order
productWords[, .(Frequency = .N), by = V1][order(-Frequency)]

# Remove salsa products
transactionData <- transactionData[!grepl("salsa", tolower(PROD_NAME)), ]

# Summarise the data to check for nulls and possible outliers
summary(transactionData)

# Filter the dataset to find the outlier
transactionData[PROD_QTY == 200]

# There are two transactions where 200 packets of chips are bought in one transaction and both of these transactions were by the same customer.
transactionData[LYLTY_CARD_NBR == "226000", .(LYLTY_CARD_NBR, PROD_NAME, PROD_QTY)]

# Let Us see if the customer has had other transactions
transactionData[LYLTY_CARD_NBR == "226000", .(LYLTY_CARD_NBR, DATE, PROD_NAME, PROD_QTY)]

# Filter out the customer based on the loyalty card number
transactionData <- transactionData[LYLTY_CARD_NBR != "226000"]

# Re-examine transaction data
str(transactionData)

# Count the number of transactions by date
transactions_by_day <- transactionData[, .N, DATE]

# Create a sequence of dates and join this with the count of transactions by date to fill in the missing day.
date_sequence <- data.table(DATE = seq(as.Date("2018-07-01"), as.Date("2019-06-30"), by = "days"))
transactions_by_day <- merge(date_sequence, transactions_by_day, all.x = TRUE, by = "DATE")

# Setting plot themes to format graphs
theme_set(theme_bw())
theme_update(plot.title = element_text(hjust = 0.5))

# Plot transactions over time
ggplot(transactions_by_day, aes(x = DATE, y = N)) +
  geom_line() +
  labs(x = "Day", y = "Number of transactions", title = "Transactions over time") +
  scale_x_date(breaks = "1 month") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5))

# Filter to December and look at individual days
transactions_by_day_dec <- transactions_by_day[format(DATE, "%m") == "12"]
ggplot(transactions_by_day_dec, aes(x = DATE, y = N)) +
  geom_line() +
  labs(x = "Day", y = "Number of transactions", title = "Transactions in December") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5))

# Pack size
# We can work this out by taking the digits that are in PROD_NAME
transactionData[, PACK_SIZE := parse_number(PROD_NAME)]

# Check if the pack sizes look sensible
transactionData[, .N, PACK_SIZE][order(PACK_SIZE)]

# Plot a histogram showing the number of transactions by pack size.
ggplot(transactionData, aes(x = PACK_SIZE)) +
  geom_histogram(binwidth = 10) +
  labs(x = "Pack Size", y = "Number of Transactions", title = "Number of Transactions by Pack Size") +
  theme_minimal()

# Brands
# Create a column which contains the brand of the product, by extracting it from the product name.
transactionData[, BRAND := tolower(gsub("\\d|\\W", "", strsplit(PROD_NAME, " ")[[1]][1]))]

# Check the results look reasonable.
transactionData[, .N, BRAND][order(-N)]

# Clean brand names
transactionData[BRAND == "red", BRAND := "rrd"]
# Check again
transactionData[, .N, BRAND][order(-N)]

# Examining customer data
# Examining customer data
# Do some basic summaries of the dataset, including distributions of any key columns.
summary(customerData)

# Merge transaction data to customer data
data <- merge(transactionData, customerData, all.x = TRUE)

# Check if some customers were not matched on by checking for nulls.
sum(is.na(data$LYLTY_CARD_NBR))

# Examining merged dataset
summary(data)

# Deep dive into Mainstream, young singles/couples
# Work out if there are brands that these two customer segments prefer more than others.
brand_preference <- data[LIFESTAGE == "YOUNG SINGLES/COUPLES" | PREMIUM_CUSTOMER == "MAINSTREAM", .N, by = BRAND][order(-N)]
brand_preference

# Look at the pack size preference
packsize_preference <- data[LIFESTAGE == "YOUNG SINGLES/COUPLES" | PREMIUM_CUSTOMER == "MAINSTREAM", .N, by = PACK_SIZE][order(-N)]
packsize_preference

# Perform an independent t-test between mainstream vs premium and budget midage and young singles and couples
t.test(data[PREMIUM_CUSTOMER == "MAINSTREAM" | (LIFESTAGE == "MIDAGE SINGLES/COUPLES" | LIFESTAGE == "YOUNG SINGLES/COUPLES"), .(PACK_SIZE)])

# Data analysis on customer segments
# Calculate total sales by LIFESTAGE and PREMIUM_CUSTOMER and plot the split by these segments to describe which customer segment contributes most to chip sales.
total_sales <- data[, .(total_sales = sum(TOT_SALES)), by = .(LIFESTAGE, PREMIUM_CUSTOMER)]
ggplot(total_sales, aes(x = reorder(LIFESTAGE, -total_sales), y = total_sales, fill = PREMIUM_CUSTOMER)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(x = "LIFESTAGE", y = "Total Sales", title = "Total Sales by LIFESTAGE and PREMIUM_CUSTOMER") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Calculate number of customers by LIFESTAGE and PREMIUM_CUSTOMER and plot the split by these segments.
num_customers <- data[, .(num_customers = length(unique(LYLTY_CARD_NBR))), by = .(LIFESTAGE, PREMIUM_CUSTOMER)]
ggplot(num_customers, aes(x = reorder(LIFESTAGE, -num_customers), y = num_customers, fill = PREMIUM_CUSTOMER)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(x = "LIFESTAGE", y = "Number of Customers", title = "Number of Customers by LIFESTAGE and PREMIUM_CUSTOMER") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Calculate average number of units per customer by LIFESTAGE and PREMIUM_CUSTOMER and plot the split by these segments.
avg_units_per_customer <- data[, .(avg_units_per_customer = mean(PROD_QTY)), by = .(LIFESTAGE, PREMIUM_CUSTOMER)]
ggplot(avg_units_per_customer, aes(x = reorder(LIFESTAGE, -avg_units_per_customer), y = avg_units_per_customer, fill = PREMIUM_CUSTOMER)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(x = "LIFESTAGE", y = "Average Units per Customer", title = "Average Units per Customer by LIFESTAGE and PREMIUM_CUSTOMER") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Calculate average price per unit by LIFESTAGE and PREMIUM_CUSTOMER and plot the split by these segments.
avg_price_per_unit <- data[, .(avg_price_per_unit = mean(TOT_SALES / PROD_QTY)), by = .(LIFESTAGE, PREMIUM_CUSTOMER)]
ggplot(avg_price_per_unit, aes(x = reorder(LIFESTAGE, -avg_price_per_unit), y = avg_price_per_unit, fill = PREMIUM_CUSTOMER)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(x = "LIFESTAGE", y = "Average Price per Unit", title = "Average Price per Unit by LIFESTAGE and PREMIUM_CUSTOMER") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
